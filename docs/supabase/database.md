# Estrutura de Banco de Dados no Supabase

Este documento descreve as tabelas necessárias para o funcionamento do aplicativo Book Log utilizando Supabase.

---

## 1. Usuários

A tabela de usuários é gerenciada automaticamente pelo Supabase Auth. Não é necessário criar manualmente esta tabela.

- **Tabela interna:** `auth.users`
- **Campos principais:**  
  - `id` (UUID, chave primária)
  - `email` (string)
  - `created_at` (timestamp)
  - Outros campos gerenciados pelo Supabase

> **Observação:** Utilize o campo `id` para vincular dados do usuário em outras tabelas.

---

## 2. Livros

Tabela personalizada para armazenar os livros de cada usuário.

- **Nome da tabela:** `books`
- **Campos sugeridos:**
  - `id` (UUID, chave primária)
  - `user_id` (UUID, referência ao usuário autenticado, vinculado a `auth.users.id`)
  - `title`   (string)
  - `author` (string)
  - `genre` (string)
  - `status` (enum: `'lido'` / `'não lido'`)
  - `rating` (integer, 0-5)
  - `cover_url` (string, URL da imagem no Supabase Storage)
  - `notes` (text)
  - `created_at` (timestamp)
  - `updated_at` (timestamp)

- **Esquema criado no Supabase:**

´´´sql
create table public.books (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  title text null,
  rating smallint null,
  author text null,
  genre character varying null,
  status character varying null,
  cover_url text null,
  notes text null,
  user_id uuid not null default auth.uid (),
  constraint books_pkey primary key (id)
) TABLESPACE pg_default;
´´´

- **Relacionamento:**
  Cada registro de livro está vinculado a um usuário pelo campo `user_id`.

---

## 3. Permissões (Row Level Security - RLS)

É necessário configurar Row Level Security (RLS) para garantir que cada usuário só acesse seus próprios livros.

### Configuração das Políticas RLS

Execute o script SQL abaixo no **SQL Editor** do Supabase para configurar as políticas de segurança:

```sql
-- 1. Habilitar RLS na tabela books
ALTER TABLE public.books ENABLE ROW LEVEL SECURITY;

-- 2. Política para SELECT: Usuários só podem ver seus próprios livros
CREATE POLICY "Users can view their own books"
ON public.books
FOR SELECT
USING (auth.uid() = user_id);

-- 3. Política para INSERT: Usuários só podem inserir livros para si mesmos
CREATE POLICY "Users can insert their own books"
ON public.books
FOR INSERT
WITH CHECK (auth.uid() = user_id);

-- 4. Política para UPDATE: Usuários só podem atualizar seus próprios livros
CREATE POLICY "Users can update their own books"
ON public.books
FOR UPDATE
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- 5. Política para DELETE: Usuários só podem deletar seus próprios livros
CREATE POLICY "Users can delete their own books"
ON public.books
FOR DELETE
USING (auth.uid() = user_id);
```

**Arquivo disponível em:** `docs/supabase/rls_policies.sql`

> **Importante:** Sem essas políticas RLS, você receberá erros `42501 (Forbidden)` ao tentar inserir, atualizar ou deletar registros.

---

## 4. Armazenamento de Imagens

Para armazenar capas de livros, utilize o Supabase Storage. O campo `cover_url` deve guardar o link para a imagem.

---

## Resumo

- **Usuários:** Gerenciado pelo Supabase Auth (`auth.users`)
- **Livros:** Tabela personalizada `books` vinculada ao usuário
- **Segurança:** RLS para proteger os dados de cada usuário

## Supabase Flutter package

### Selecionar e inserir dados  

```dart
// Select data with filters
final data = await supabase
  .from('cities')
  .select()
  .eq('country_id', 1) // equals filter
  .neq('name', 'The shire'); // does not equal filter

// Insert a new row
await supabase
  .from('cities')
  .insert({'name': 'The Shire', 'country_id': 554});
```

### Atualização de dados em Realtime

```dart
class MyWidget extends StatefulWidget {
  const MyWidget({Key? key}) : super(key: key);

  @override
  State<MyWidget> createState() => _MyWidgetState();
}

class _MyWidgetState extends State<MyWidget> {
  // Persisting the future as local variable to prevent refetching upon rebuilds.
  final stream = supabase.from('countries').stream(primaryKey: ['id']);

  @override
  Widget build(BuildContext context) {
    return StreamBuilder<List<Map<String, dynamic>>>(
      stream: stream,
      builder: (context, snapshot) {
        // return your widget with the data from snapshot
      },
    );
  }
}
```

### Postgres Changes

- Você pode ser notificado quando há uma mudança nas tabelas do Supabase:

```dart
final myChannel = supabase.channel('my_channel');

myChannel
    .onPostgresChanges(
      event: PostgresChangeEvent.all,
      schema: 'public',
      table: 'countries',
      callback: (payload) {
        // Do something fun or interesting when there is an change on the database
      },
    )
    .subscribe();
```
